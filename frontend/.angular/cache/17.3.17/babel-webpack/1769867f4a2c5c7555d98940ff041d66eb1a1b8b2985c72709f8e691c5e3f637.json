{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport let WebsocketService = /*#__PURE__*/(() => {\n  class WebsocketService {\n    constructor() {\n      this.sensorsSubject = new BehaviorSubject(null);\n      this.sensors$ = this.sensorsSubject.asObservable();\n      this.connectionStatus = new BehaviorSubject('disconnected');\n      this.connectionStatus$ = this.connectionStatus.asObservable();\n      this.ws = null;\n      this.simulationMode = false;\n      this.simulationInterval = null;\n      this.reconnectTimeout = null;\n      console.log('ðŸ”§ WebSocket Service inicializado - URL DINÃMICA');\n      this.connectToBackend();\n    }\n    getWebSocketUrl() {\n      // URL para Kubernetes - usar el servicio del backend\n      if (window.location.hostname.includes('192.168.49.2') || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {\n        // Si estamos en Minikube o desarrollo local\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        const host = window.location.hostname.includes('192.168.49.2') ? 'backend.skysense.svc.cluster.local:8000' : 'localhost:8000';\n        return `${protocol}//${host}/ws/sensors`;\n      } else {\n        // Para producciÃ³n, usar el host actual\n        const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\n        return `${protocol}//${window.location.host}/ws/sensors`;\n      }\n    }\n    connectToBackend() {\n      try {\n        const wsUrl = this.getWebSocketUrl();\n        console.log('ðŸ”„ Connecting to backend...');\n        console.log('   - Current host:', window.location.host);\n        console.log('   - WebSocket URL:', wsUrl);\n        this.connectionStatus.next('connecting');\n        this.ws = new WebSocket(wsUrl);\n        this.ws.onopen = () => {\n          console.log('âœ… CONNECTED to backend WebSocket');\n          console.log('   - Connection established to:', wsUrl);\n          this.connectionStatus.next('connected');\n          this.simulationMode = false;\n          if (this.simulationInterval) {\n            clearInterval(this.simulationInterval);\n            this.simulationInterval = null;\n          }\n        };\n        this.ws.onmessage = event => {\n          try {\n            const data = JSON.parse(event.data);\n            console.log('ðŸ“Š Received real sensor data:', data.sensor_id);\n            this.sensorsSubject.next(data);\n          } catch (error) {\n            console.error('âŒ Error parsing WebSocket message:', error);\n          }\n        };\n        this.ws.onerror = error => {\n          console.error('âŒ WebSocket connection error');\n          console.error('   - URL attempted:', this.getWebSocketUrl());\n          console.error('   - Error details:', error);\n          this.connectionStatus.next('error');\n          this.startSimulation();\n        };\n        this.ws.onclose = event => {\n          console.log('ðŸ”Œ WebSocket connection closed');\n          console.log('   - Close code:', event.code);\n          console.log('   - Close reason:', event.reason);\n          this.connectionStatus.next('disconnected');\n          if (!this.simulationMode) {\n            console.log('ðŸ”„ Will attempt reconnect in 5 seconds...');\n            this.reconnectTimeout = setTimeout(() => {\n              this.connectToBackend();\n            }, 5000);\n          }\n        };\n      } catch (error) {\n        console.error('âŒ Failed to create WebSocket:', error);\n        this.connectionStatus.next('error');\n        this.startSimulation();\n      }\n    }\n    startSimulation() {\n      if (!this.simulationMode) {\n        console.log('ðŸŽ­ Backend not available - Starting simulation mode');\n        this.simulationMode = true;\n        this.connectionStatus.next('simulation');\n        this.simulationInterval = setInterval(() => {\n          const simulatedData = {\n            sensor_id: 'simulated_' + Math.floor(5 * Math.random()),\n            temperature: 20 + 15 * Math.random(),\n            humidity: 40 + 40 * Math.random(),\n            pressure: 990 + 40 * Math.random(),\n            timestamp: new Date().toISOString()\n          };\n          console.log('ðŸŽ­ SIMULATED data (fallback mode):', simulatedData);\n          this.sensorsSubject.next(simulatedData);\n        }, 2000);\n      }\n    }\n    isSimulationMode() {\n      return this.simulationMode;\n    }\n    disconnect() {\n      if (this.reconnectTimeout) {\n        clearTimeout(this.reconnectTimeout);\n        this.reconnectTimeout = null;\n      }\n      if (this.simulationInterval) {\n        clearInterval(this.simulationInterval);\n        this.simulationMode = false;\n        this.simulationInterval = null;\n      }\n      if (this.ws) {\n        this.ws.close();\n        this.ws = null;\n      }\n    }\n    connect() {\n      this.disconnect();\n      this.connectToBackend();\n    }\n    toggleSimulationMode() {\n      if (this.simulationMode) {\n        this.disconnect();\n        this.connectToBackend();\n      } else {\n        this.disconnect();\n        this.startSimulation();\n      }\n    }\n    reconnect() {\n      this.connect();\n    }\n    close() {\n      this.disconnect();\n    }\n    static {\n      this.Éµfac = function WebsocketService_Factory(t) {\n        return new (t || WebsocketService)();\n      };\n    }\n    static {\n      this.Éµprov = /*@__PURE__*/i0.ÉµÉµdefineInjectable({\n        token: WebsocketService,\n        factory: WebsocketService.Éµfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WebsocketService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}